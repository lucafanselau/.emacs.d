;;; loaddefs.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:


;;;### (autoloads nil "term-autoloads" "term-autoloads.el" (0 0 0
;;;;;;  0))
;;; Generated autoloads from term-autoloads.el

(autoload 'my/vterm "term-autoloads" "\
open vterm at project root, if no root is found, open at the default-directory" t)

(autoload 'my/project-root-or-default-dir "term-autoloads" "\
If a project root is found, return it. Otherwise return `default-directory'.")

(autoload 'my/get-scripts "term-autoloads")

(autoload 'my/vterm-run-command "term-autoloads" "\
Run the command CMD In a new vterm buffer with the name NAME if it not exists, otherwise switch to the existing buffer of name NAME and execute command CMD.

\(fn CMD NAME)")

(autoload 'my/run-scripts "term-autoloads" nil t)

(register-definition-prefixes "term-autoloads" '("lf/npm-client"))

;;;***

;;;### (autoloads nil "utils-autoloads" "utils-autoloads.el" (0 0
;;;;;;  0 0))
;;; Generated autoloads from utils-autoloads.el

(autoload 'my/update-all-autoloads "utils-autoloads" nil t)

(autoload 'my/run-hook-once "utils-autoloads"
  "\
a wrapper to run a func on a hook only once

\(fn HOOK FUNC &rest ARGS)"
  nil t)

(autoload 'my/advise-at-once "utils-autoloads"
  "\
a wrapper to advise a func only once

\(fn FUNC ADVICE WHERE &rest PROPS)"
  nil t)

(autoload 'my/turn-off-mode "utils-autoloads"
  "\
Create a function to turn off MODE. Useful for attaching on some
hooks that will turn off MODE locally.

\(fn MODE)"
  nil t)

(autoload 'my/setq-locally "utils-autoloads"
  "\
Create a function to set VAR to VAL locally. Useful for attaching
on some hooks that will change the variable locally.

Use `my/setq-locally' when you want to set VAR to a simple VAL in many
modes.  Use `my/setq-on-hook' when you want to set VAR to a complex
VAL in only one mode.  Why don't I just directly use `(add-hook
'foo-hook (lambda () (FORM)))'?  Because when you try to
\\[describe-variable] `foo-hook RET', you will find those lambda
functions unreadable. And using a named function in a hook makes the
hook described much more nicely.  This is very helpful for debugging
purpose if you want to examine a hook value.

\(fn VAR VAL)"
  nil t)

(autoload 'my/setq-on-hook "utils-autoloads"
  "\
Create a function to set VAR to VAL on a HOOK.

Use `my/setq-locally' when you want to set VAR to a simple VAL in many
modes.  Use `my/setq-on-hook' when you want to set VAR to a complex
VAL in only one mode.  Why don't I just directly use `(add-hook
'foo-hook (lambda () (FORM)))'?  Because when you try to
\\[describe-variable] `foo-hook RET', you will find those lambda
functions unreadable. And using a named function in a hook makes the
hook described much more nicely.  This is very helpful for debugging
purpose if you want to examine a hook value.

\(fn HOOK VAR VAL)"
  nil t)

;;;***

;;; End of scraped data

(provide 'loaddefs)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; loaddefs.el ends here
